# Trae Agent 工具系统完整指南 - 技术详解

## 1. 工具系统概述

Trae Agent 的工具系统是其核心功能之一，它允许智能体执行各种操作来完成软件工程任务。工具系统采用插件化架构，支持动态注册和扩展，使得系统可以轻松添加新的工具功能。

## 2. 工具架构设计

### 2.1 工具基类

所有工具都继承自 `Tool` 基类，该基类定义了工具的基本接口：

```python
class Tool(ABC):
    def __init__(self, model_provider: str | None = None) -> None:
        self._model_provider = model_provider

    @abstractmethod
    def get_name(self) -> str:
        """获取工具名称"""
        pass

    @abstractmethod
    def get_description(self) -> str:
        """获取工具描述"""
        pass

    @abstractmethod
    def get_parameters(self) -> list[ToolParameter]:
        """获取工具参数定义"""
        pass

    @abstractmethod
    async def execute(self, arguments: ToolCallArguments) -> ToolExecResult:
        """执行工具"""
        pass

    async def close(self):
        """关闭工具资源"""
        pass
```

### 2.2 工具参数定义

工具参数通过 `ToolParameter` 类定义：

```python
@dataclass
class ToolParameter:
    name: str
    type: str
    description: str
    required: bool = False
    enum: list[str] | None = None
    items: dict[str, Any] | None = None
```

### 2.3 工具执行结果

工具执行结果通过 `ToolExecResult` 类表示：

```python
@dataclass
class ToolExecResult:
    output: str | None = None
    error: str | None = None
    error_code: int | None = None
    success: bool = True
```

## 3. 核心工具详解

### 3.1 编辑工具 (TextEditorTool)

编辑工具是Trae Agent中最核心的工具之一，它允许代理查看、创建和修改文件。

#### 3.1.1 工具功能

编辑工具支持以下子命令：
1. `view`: 查看文件或目录内容
2. `create`: 创建新文件
3. `str_replace`: 字符串替换
4. `insert`: 插入内容

#### 3.1.2 工具实现

```python
class TextEditorTool(Tool):
    def get_name(self) -> str:
        return "str_replace_based_edit_tool"

    def get_description(self) -> str:
        return """Custom editing tool for viewing, creating and editing files
* State is persistent across command calls and discussions with the user
* If `path` is a file, `view` displays the result of applying `cat -n`. If `path` is a directory, `view` lists non-hidden files and directories up to 2 levels deep
* The `create` command cannot be used if the specified `path` already exists as a file !!! If you know that the `path` already exists, please remove it first and then perform the `create` operation!
* If a `command` generates a long output, it will be truncated and marked with `<response clipped>`
"""

    def get_parameters(self) -> list[ToolParameter]:
        return [
            ToolParameter(
                name="command",
                type="string",
                description=f"The commands to run. Allowed options are: {', '.join(EditToolSubCommands)}.",
                required=True,
                enum=EditToolSubCommands,
            ),
            # ... 其他参数定义
        ]

    async def execute(self, arguments: ToolCallArguments) -> ToolExecResult:
        command = str(arguments["command"]) if "command" in arguments else None
        path = str(arguments["path"]) if "path" in arguments else None
        _path = Path(path)
        
        try:
            self.validate_path(command, _path)
            match command:
                case "view":
                    return await self._view_handler(arguments, _path)
                case "create":
                    return self._create_handler(arguments, _path)
                case "str_replace":
                    return self._str_replace_handler(arguments, _path)
                case "insert":
                    return self._insert_handler(arguments, _path)
                case _:
                    return ToolExecResult(
                        error=f"Unrecognized command {command}. The allowed commands for the {self.name} tool are: {', '.join(EditToolSubCommands)}",
                        error_code=-1,
                    )
        except ToolError as e:
            return ToolExecResult(error=str(e), error_code=-1)
```

#### 3.1.3 关键功能实现

1. **路径验证**:
```python
def validate_path(self, command: str, path: Path):
    """验证路径"""
    if not path.is_absolute():
        suggested_path = Path("/") / path
        raise ToolError(
            f"The path {path} is not an absolute path, it should start with `/`. Maybe you meant {suggested_path}?"
        )
    # 检查路径是否存在
    if not path.exists() and command != "create":
        raise ToolError(f"The path {path} does not exist. Please provide a valid path.")
    # 检查路径是否指向目录
    if path.is_dir() and command != "view":
        raise ToolError(
            f"The path {path} is a directory and only the `view` command can be used on directories"
        )
```

2. **查看功能**:
```python
async def _view(self, path: Path, view_range: list[int] | None = None) -> ToolExecResult:
    """实现查看命令"""
    if path.is_dir():
        # 查看目录内容
        return_code, stdout, stderr = await run(rf"find {path} -maxdepth 2 -not -path '*/\.*'")
        if not stderr:
            stdout = f"Here's the files and directories up to 2 levels deep in {path}, excluding hidden items:\n{stdout}\n"
        return ToolExecResult(error_code=return_code, output=stdout, error=stderr)
    
    # 查看文件内容
    file_content = self.read_file(path)
    init_line = 1
    if view_range:
        # 处理行范围
        file_lines = file_content.split("\n")
        n_lines_file = len(file_lines)
        init_line, final_line = view_range
        # ... 范围验证和内容提取
    
    return ToolExecResult(
        output=self._make_output(file_content, str(path), init_line=init_line)
    )
```

3. **字符串替换**:
```python
def str_replace(self, path: Path, old_str: str, new_str: str | None) -> ToolExecResult:
    """实现字符串替换命令"""
    # 读取文件内容
    file_content = self.read_file(path).expandtabs()
    old_str = old_str.expandtabs()
    new_str = new_str.expandtabs() if new_str is not None else ""

    # 检查old_str在文件中的唯一性
    occurrences = file_content.count(old_str)
    if occurrences == 0:
        raise ToolError(
            f"No replacement was performed, old_str `{old_str}` did not appear verbatim in {path}."
        )
    elif occurrences > 1:
        file_content_lines = file_content.split("\n")
        lines = [idx + 1 for idx, line in enumerate(file_content_lines) if old_str in line]
        raise ToolError(
            f"No replacement was performed. Multiple occurrences of old_str `{old_str}` in lines {lines}. Please ensure it is unique"
        )

    # 执行替换
    new_file_content = file_content.replace(old_str, new_str)
    self.write_file(path, new_file_content)

    # 创建编辑片段
    replacement_line = file_content.split(old_str)[0].count("\n")
    start_line = max(0, replacement_line - SNIPPET_LINES)
    end_line = replacement_line + SNIPPET_LINES + new_str.count("\n")
    snippet = "\n".join(new_file_content.split("\n")[start_line : end_line + 1])

    # 准备成功消息
    success_msg = f"The file {path} has been edited. "
    success_msg += self._make_output(snippet, f"a snippet of {path}", start_line + 1)
    success_msg += "Review the changes and make sure they are as expected. Edit the file again if necessary."

    return ToolExecResult(output=success_msg)
```

### 3.2 Bash工具 (BashTool)

Bash工具允许智能体在bash shell中执行命令。

#### 3.2.1 工具实现

```python
class BashTool(Tool):
    def get_name(self) -> str:
        return "bash"

    def get_description(self) -> str:
        return """Run commands in a bash shell
* When invoking this tool, the contents of the "command" parameter does NOT need to be XML-escaped.
* You have access to a mirror of common linux and python packages via apt and pip.
* State is persistent across command calls and discussions with the user.
* To inspect a particular line range of a file, e.g. lines 10-25, try 'sed -n 10,25p /path/to/the/file'.
* Please avoid commands that may produce a very large amount of output.
* Please run long lived commands in the background, e.g. 'sleep 10 &' or start a server in the background.
"""

    def get_parameters(self) -> list[ToolParameter]:
        return [
            ToolParameter(
                name="command",
                type="string",
                description="The bash command to run.",
                required=True,
            ),
            ToolParameter(
                name="restart",
                type="boolean",
                description="Set to true to restart the bash session.",
                required=False,
            ),
        ]

    async def execute(self, arguments: ToolCallArguments) -> ToolExecResult:
        if arguments.get("restart"):
            # 重启会话
            if self._session:
                await self._session.stop()
            self._session = _BashSession()
            await self._session.start()
            return ToolExecResult(output="tool has been restarted.")

        # 启动会话（如果需要）
        if self._session is None:
            try:
                self._session = _BashSession()
                await self._session.start()
            except Exception as e:
                return ToolExecResult(error=f"Error starting bash session: {e}", error_code=-1)

        command = str(arguments["command"]) if "command" in arguments else None
        if command is None:
            return ToolExecResult(
                error=f"No command provided for the {self.get_name()} tool",
                error_code=-1,
            )
        try:
            return await self._session.run(command)
        except Exception as e:
            return ToolExecResult(error=f"Error running bash command: {e}", error_code=-1)
```

#### 3.2.2 Bash会话管理

```python
class _BashSession:
    def __init__(self) -> None:
        self._started = False
        self._timed_out = False
        self._process: asyncio.subprocess.Process | None = None

    async def start(self) -> None:
        """启动bash会话"""
        if self._started:
            return

        # 根据操作系统启动不同的shell
        if os.name != "nt":  # Unix-like systems
            self._process = await asyncio.create_subprocess_shell(
                self.command,
                shell=True,
                bufsize=0,
                stdin=asyncio.subprocess.PIPE,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                preexec_fn=os.setsid,
            )
        else:
            self._process = await asyncio.create_subprocess_shell(
                "cmd.exe /v:on",
                shell=True,
                bufsize=0,
                stdin=asyncio.subprocess.PIPE,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
            )

        self._started = True

    async def run(self, command: str) -> ToolExecResult:
        """执行命令"""
        if not self._started or self._process is None:
            raise ToolError("Session has not started.")
        
        # 发送命令到进程
        sentinel_before, pivot, sentinel_after = self._sentinel.partition("__ERROR_CODE__")
        errcode_retriever = "!errorlevel!" if os.name == "nt" else "$?"
        command_sep = "&" if os.name == "nt" else ";"
        
        self._process.stdin.write(
            b"(\n"
            + command.encode()
            + f"\n){command_sep} echo {self._sentinel.replace('__ERROR_CODE__', errcode_retriever)}\n".encode()
        )
        await self._process.stdin.drain()

        # 读取输出直到哨兵出现
        try:
            async with asyncio.timeout(self._timeout):
                while True:
                    await asyncio.sleep(self._output_delay)
                    output: str = self._process.stdout._buffer.decode()
                    if sentinel_before in output:
                        # 处理输出和错误码
                        output, pivot, exit_banner = output.rpartition(sentinel_before)
                        error_code_str, pivot, _ = exit_banner.partition(sentinel_after)
                        if not pivot or not error_code_str.isdecimal():
                            continue
                        error_code = int(error_code_str)
                        break
        except asyncio.TimeoutError:
            self._timed_out = True
            raise ToolError(
                f"timed out: bash has not returned in {self._timeout} seconds and must be restarted",
            ) from None

        # 清理输出
        if output.endswith("\n"):
            output = output[:-1]
            
        error: str = self._process.stderr._buffer.decode()
        if error.endswith("\n"):
            error = error[:-1]

        # 清空缓冲区
        self._process.stdout._buffer.clear()
        self._process.stderr._buffer.clear()

        return ToolExecResult(output=output, error=error, error_code=error_code)
```

### 3.3 顺序思考工具 (SequentialThinkingTool)

顺序思考工具帮助智能体进行深入的分析和思考。

#### 3.3.1 工具实现

```python
class SequentialThinkingTool(Tool):
    def get_name(self) -> str:
        return "sequentialthinking"

    def get_description(self) -> str:
        return """Break down complex problems into sequential thoughts.
Use this tool when you need to think through a problem step by step.
You can run bash commands or use other tools between thoughts.
"""

    def get_parameters(self) -> list[ToolParameter]:
        return [
            ToolParameter(
                name="total_thoughts",
                type="integer",
                description="Total number of thoughts to generate.",
                required=True,
            ),
            ToolParameter(
                name="current_thought_index",
                type="integer",
                description="Current thought index (1-based).",
                required=True,
            ),
            ToolParameter(
                name="thought",
                type="string",
                description="The current thought content.",
                required=True,
            ),
            ToolParameter(
                name="is_final",
                type="boolean",
                description="Whether this is the final thought.",
                required=False,
            ),
        ]

    async def execute(self, arguments: ToolCallArguments) -> ToolExecResult:
        total_thoughts = arguments.get("total_thoughts")
        current_thought_index = arguments.get("current_thought_index")
        thought = arguments.get("thought")
        is_final = arguments.get("is_final", False)
        
        if not all(isinstance(x, int) for x in [total_thoughts, current_thought_index]):
            return ToolExecResult(
                error="total_thoughts and current_thought_index must be integers",
                error_code=-1
            )
            
        if not isinstance(thought, str):
            return ToolExecResult(
                error="thought must be a string",
                error_code=-1
            )
        
        # 生成响应
        response = f"Thought {current_thought_index}/{total_thoughts}: {thought}"
        if is_final:
            response += "\n\nThis concludes my sequential thinking process."
            
        return ToolExecResult(output=response)
```

### 3.4 任务完成工具 (TaskDoneTool)

任务完成工具用于标记任务完成。

#### 3.4.1 工具实现

```python
class TaskDoneTool(Tool):
    def get_name(self) -> str:
        return "task_done"

    def get_description(self) -> str:
        return "Mark the task as completed."

    def get_parameters(self) -> list[ToolParameter]:
        return [
            ToolParameter(
                name="reason",
                type="string",
                description="Reason for marking the task as completed.",
                required=False,
            )
        ]

    async def execute(self, arguments: ToolCallArguments) -> ToolExecResult:
        reason = arguments.get("reason", "Task completed successfully.")
        return ToolExecResult(
            output=f"Task marked as completed. Reason: {reason}"
        )
```

## 4. 技术实现要点

### 4.1 工具基类实现

#### 知识点1: 工具基类和抽象方法
在Node.js中，我们可以使用ES6类和抽象方法来实现工具基类。

```javascript
// 知识点1: 工具基类和抽象方法
// 在Node.js中，我们可以使用ES6类和抽象方法来实现工具基类

// 自定义工具错误类
class ToolError extends Error {
  constructor(message) {
    super(message);
    this.name = 'ToolError';
  }
}

// 工具执行结果类
class ToolExecResult {
  constructor({ output = null, error = null, errorCode = 0, success = true } = {}) {
    this.output = output;
    this.error = error;
    this.errorCode = errorCode;
    this.success = success;
  }
}

// 工具调用参数类型
class ToolCallArguments {
  constructor(args = {}) {
    this.arguments = args;
  }

  get(key) {
    return this.arguments[key];
  }

  has(key) {
    return key in this.arguments;
  }
}

// 工具参数定义类
class ToolParameter {
  constructor({ name, type, description, required = false, enumValues = null, items = null }) {
    this.name = name;
    this.type = type;
    this.description = description;
    this.required = required;
    this.enum = enumValues;
    this.items = items;
  }
}

// 工具基类
class Tool {
  constructor({ modelProvider = null } = {}) {
    this.modelProvider = modelProvider;
  }

  // 获取工具名称（抽象方法）
  getName() {
    throw new Error('getName method must be implemented by subclass');
  }

  // 获取工具描述（抽象方法）
  getDescription() {
    throw new Error('getDescription method must be implemented by subclass');
  }

  // 获取工具参数定义（抽象方法）
  getParameters() {
    throw new Error('getParameters method must be implemented by subclass');
  }

  // 执行工具（抽象方法）
  async execute(arguments) {
    throw new Error('execute method must be implemented by subclass');
  }

  // 关闭工具资源
  async close() {
    // 默认实现，子类可以覆盖
    return null;
  }

  // 获取模型提供商
  getModelProvider() {
    return this.modelProvider;
  }

  // 获取输入模式
  getInputSchema() {
    const schema = {
      type: "object"
    };

    const properties = {};
    const required = [];

    for (const param of this.getParameters()) {
      const paramSchema = {
        type: param.type,
        description: param.description
      };

      // 对于OpenAI模型，所有参数都必须在'required'中
      // 可选参数被设为"nullable"以符合规范
      if (this.modelProvider === "openai") {
        required.push(param.name);
        if (!param.required) {
          const currentType = paramSchema.type;
          if (typeof currentType === 'string') {
            paramSchema.type = [currentType, "null"];
          } else if (Array.isArray(currentType) && !currentType.includes("null")) {
            paramSchema.type = [...currentType, "null"];
          }
        }
      } else if (param.required) {
        required.push(param.name);
      }

      if (param.enum) {
        paramSchema.enum = param.enum;
      }

      if (param.items) {
        paramSchema.items = param.items;
      }

      // 对于OpenAI，嵌套对象也需要additionalProperties: false
      if (this.modelProvider === "openai" && param.type === "object") {
        paramSchema.additionalProperties = false;
      }

      properties[param.name] = paramSchema;
    }

    schema.properties = properties;
    if (required.length > 0) {
      schema.required = required;
    }

    // 对于OpenAI，顶级模式需要additionalProperties: false
    if (this.modelProvider === "openai") {
      schema.additionalProperties = false;
    }

    return schema;
  }

  // 获取工具定义
  jsonDefinition() {
    return {
      name: this.getName(),
      description: this.getDescription(),
      parameters: this.getInputSchema()
    };
  }
}
```

### 4.2 编辑工具实现

#### 知识点2: 文件编辑工具实现
编辑工具是Trae Agent中最核心的工具之一，它允许代理查看、创建和修改文件。

```javascript
// 知识点2: 文件编辑工具实现
// 编辑工具是Trae Agent中最核心的工具之一，它允许代理查看、创建和修改文件

const fs = require('fs').promises;
const path = require('path');
const { exec } = require('child_process');
const { promisify } = require('util');

const execAsync = promisify(exec);

// 编辑工具子命令
const EditToolSubCommands = [
  "view",
  "create",
  "str_replace",
  "insert"
];

// 代码片段行数
const SNIPPET_LINES = 4;

// 文本编辑工具类
class TextEditorTool extends Tool {
  constructor({ modelProvider = null } = {}) {
    super({ modelProvider });
  }

  // 获取工具名称
  getName() {
    return "str_replace_based_edit_tool";
  }

  // 获取工具描述
  getDescription() {
    return `Custom editing tool for viewing, creating and editing files
* State is persistent across command calls and discussions with the user
* If \`path\` is a file, \`view\` displays the result of applying \`cat -n\`. If \`path\` is a directory, \`view\` lists non-hidden files and directories up to 2 levels deep
* The \`create\` command cannot be used if the specified \`path\` already exists as a file !!! If you know that the \`path\` already exists, please remove it first and then perform the \`create\` operation!
* If a \`command\` generates a long output, it will be truncated and marked with \`<response clipped>\`

Notes for using the \`str_replace\` command:
* The \`old_str\` parameter should match EXACTLY one or more consecutive lines from the original file. Be mindful of whitespaces!
* If the \`old_str\` parameter is not unique in the file, the replacement will not be performed. Make sure to include enough context in \`old_str\` to make it unique
* The \`new_str\` parameter should contain the edited lines that should replace the \`old_str\``;
  }

  // 获取工具参数
  getParameters() {
    return [
      new ToolParameter({
        name: "command",
        type: "string",
        description: `The commands to run. Allowed options are: ${EditToolSubCommands.join(', ')}.`,
        required: true,
        enumValues: EditToolSubCommands
      }),
      new ToolParameter({
        name: "file_text",
        type: "string",
        description: "Required parameter of `create` command, with the content of the file to be created."
      }),
      new ToolParameter({
        name: "insert_line",
        type: "integer",
        description: "Required parameter of `insert` command. The `new_str` will be inserted AFTER the line `insert_line` of `path`."
      }),
      new ToolParameter({
        name: "new_str",
        type: "string",
        description: "Optional parameter of `str_replace` command containing the new string (if not given, no string will be added). Required parameter of `insert` command containing the string to insert."
      }),
      new ToolParameter({
        name: "old_str",
        type: "string",
        description: "Required parameter of `str_replace` command containing the string in `path` to replace."
      }),
      new ToolParameter({
        name: "path",
        type: "string",
        description: "Absolute path to file or directory, e.g. `/repo/file.py` or `/repo`.",
        required: true
      }),
      new ToolParameter({
        name: "view_range",
        type: "array",
        description: "Optional parameter of `view` command when `path` points to a file. If none is given, the full file is shown. If provided, the file will be shown in the indicated line number range, e.g. [11, 12] will show lines 11 and 12. Indexing at 1 to start. Setting `[start_line, -1]` shows all lines from `start_line` to the end of the file.",
        items: { type: "integer" }
      })
    ];
  }

  // 执行工具
  async execute(arguments) {
    const command = arguments.get("command");
    if (!command) {
      return new ToolExecResult({
        error: `No command provided for the ${this.getName()} tool`,
        errorCode: -1
      });
    }

    const pathValue = arguments.get("path");
    if (!pathValue) {
      return new ToolExecResult({
        error: `No path provided for the ${this.getName()} tool`,
        errorCode: -1
      });
    }

    const _path = pathValue;
    
    try {
      this.validatePath(command, _path);
      
      switch (command) {
        case "view":
          return await this.viewHandler(arguments, _path);
        case "create":
          return this.createHandler(arguments, _path);
        case "str_replace":
          return this.strReplaceHandler(arguments, _path);
        case "insert":
          return this.insertHandler(arguments, _path);
        default:
          return new ToolExecResult({
            error: `Unrecognized command ${command}. The allowed commands for the ${this.getName()} tool are: ${EditToolSubCommands.join(', ')}`,
            errorCode: -1
          });
      }
    } catch (error) {
      if (error instanceof ToolError) {
        return new ToolExecResult({
          error: error.message,
          errorCode: -1
        });
      }
      throw error;
    }
  }

  // 验证路径
  validatePath(command, pathValue) {
    // 检查是否为绝对路径
    if (!path.isAbsolute(pathValue)) {
      const suggestedPath = path.join("/", pathValue);
      throw new ToolError(
        `The path ${pathValue} is not an absolute path, it should start with \`/\`. Maybe you meant ${suggestedPath}?`
      );
    }

    // 检查路径是否存在
    try {
      fs.accessSync(pathValue);
    } catch (error) {
      if (command !== "create") {
        throw new ToolError(`The path ${pathValue} does not exist. Please provide a valid path.`);
      }
    }

    // 检查路径是否指向目录
    try {
      const stats = fs.statSync(pathValue);
      if (stats.isDirectory() && command !== "view") {
        throw new ToolError(
          `The path ${pathValue} is a directory and only the \`view\` command can be used on directories`
        );
      }
    } catch (error) {
      // 如果路径不存在且不是create命令，上面已经处理过了
      if (command !== "create") {
        throw error;
      }
    }
  }

  // 查看处理程序
  async viewHandler(arguments, pathValue) {
    const viewRange = arguments.get("view_range");
    
    if (viewRange === undefined || viewRange === null) {
      return await this.view(pathValue, null);
    }
    
    if (!Array.isArray(viewRange) || !viewRange.every(i => Number.isInteger(i))) {
      return new ToolExecResult({
        error: "Parameter `view_range` should be a list of integers.",
        errorCode: -1
      });
    }
    
    return await this.view(pathValue, viewRange);
  }

  // 查看命令实现
  async view(pathValue, viewRange) {
    const stats = await fs.stat(pathValue);
    
    // 如果是目录
    if (stats.isDirectory()) {
      if (viewRange) {
        throw new ToolError(
          "The `view_range` parameter is not allowed when `path` points to a directory."
        );
      }

      try {
        const { stdout, stderr } = await execAsync(`find ${pathValue} -maxdepth 2 -not -path '*/\\.*'`);
        if (!stderr) {
          const output = `Here's the files and directories up to 2 levels deep in ${pathValue}, excluding hidden items:\n${stdout}\n`;
          return new ToolExecResult({ output });
        }
        return new ToolExecResult({ error: stderr, errorCode: 1 });
      } catch (error) {
        return new ToolExecResult({ error: error.message, errorCode: 1 });
      }
    }

    // 如果是文件
    let fileContent = await this.readFile(pathValue);
    let initLine = 1;
    
    if (viewRange) {
      if (viewRange.length !== 2 || !viewRange.every(i => Number.isInteger(i))) {
        throw new ToolError("Invalid `view_range`. It should be a list of two integers.");
      }
      
      const fileLines = fileContent.split("\n");
      const nLinesFile = fileLines.length;
      let [initLineValue, finalLine] = viewRange;
      
      if (initLineValue < 1 || initLineValue > nLinesFile) {
        throw new ToolError(
          `Invalid \`view_range\`: ${viewRange}. Its first element \`${initLineValue}\` should be within the range of lines of the file: [1, ${nLinesFile}]`
        );
      }
      
      if (finalLine > nLinesFile) {
        throw new ToolError(
          `Invalid \`view_range\`: ${viewRange}. Its second element \`${finalLine}\` should be smaller than the number of lines in the file: \`${nLinesFile}\``
        );
      }
      
      if (finalLine !== -1 && finalLine < initLineValue) {
        throw new ToolError(
          `Invalid \`view_range\`: ${viewRange}. Its second element \`${finalLine}\` should be larger or equal than its first \`${initLineValue}\``
        );
      }

      if (finalLine === -1) {
        fileContent = fileLines.slice(initLineValue - 1).join("\n");
      } else {
        fileContent = fileLines.slice(initLineValue - 1, finalLine).join("\n");
      }
      
      initLine = initLineValue;
    }

    return new ToolExecResult({
      output: this.makeOutput(fileContent, pathValue, initLine)
    });
  }

  // 字符串替换处理程序
  strReplaceHandler(arguments, pathValue) {
    const oldStr = arguments.get("old_str");
    if (typeof oldStr !== 'string') {
      return new ToolExecResult({
        error: "Parameter `old_str` is required and should be a string for command: str_replace",
        errorCode: -1
      });
    }
    
    const newStr = arguments.get("new_str");
    if (newStr !== null && newStr !== undefined && typeof newStr !== 'string') {
      return new ToolExecResult({
        error: "Parameter `new_str` should be a string or null for command: str_replace",
        errorCode: -1
      });
    }
    
    return this.strReplace(pathValue, oldStr, newStr);
  }

  // 字符串替换命令实现
  strReplace(pathValue, oldStr, newStr) {
    // 读取文件内容
    let fileContent = this.readFile(pathValue).replace(/\t/g, '    ');
    oldStr = oldStr.replace(/\t/g, '    ');
    newStr = newStr ? newStr.replace(/\t/g, '    ') : "";

    // 检查oldStr在文件中的唯一性
    const occurrences = (fileContent.match(new RegExp(oldStr.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g')) || []).length;
    
    if (occurrences === 0) {
      throw new ToolError(
        `No replacement was performed, old_str \`${oldStr}\` did not appear verbatim in ${pathValue}.`
      );
    } else if (occurrences > 1) {
      const fileContentLines = fileContent.split("\n");
      const lines = fileContentLines
        .map((line, idx) => (line.includes(oldStr) ? idx + 1 : null))
        .filter(line => line !== null);
      throw new ToolError(
        `No replacement was performed. Multiple occurrences of old_str \`${oldStr}\` in lines ${JSON.stringify(lines)}. Please ensure it is unique`
      );
    }

    // 执行替换
    const newFileContent = fileContent.replace(oldStr, newStr);
    this.writeFile(pathValue, newFileContent);

    // 创建编辑片段
    const replacementLine = fileContent.split(oldStr)[0].split("\n").length - 1;
    const startLine = Math.max(0, replacementLine - SNIPPET_LINES);
    const endLine = replacementLine + SNIPPET_LINES + (newStr.match(/\n/g) || []).length;
    const snippetLines = newFileContent.split("\n").slice(startLine, endLine + 1);
    const snippet = snippetLines.join("\n");

    // 准备成功消息
    let successMsg = `The file ${pathValue} has been edited. `;
    successMsg += this.makeOutput(snippet, `a snippet of ${pathValue}`, startLine + 1);
    successMsg += "Review the changes and make sure they are as expected. Edit the file again if necessary.";

    return new ToolExecResult({ output: successMsg });
  }

  // 创建处理程序
  createHandler(arguments, pathValue) {
    const fileText = arguments.get("file_text");
    if (typeof fileText !== 'string') {
      return new ToolExecResult({
        error: "Parameter `file_text` is required and must be a string for command: create",
        errorCode: -1
      });
    }
    
    this.writeFile(pathValue, fileText);
    return new ToolExecResult({ output: `File created successfully at: ${pathValue}` });
  }

  // 插入处理程序
  insertHandler(arguments, pathValue) {
    const insertLine = arguments.get("insert_line");
    if (!Number.isInteger(insertLine)) {
      return new ToolExecResult({
        error: "Parameter `insert_line` is required and should be integer for command: insert",
        errorCode: -1
      });
    }
    
    const newStrToInsert = arguments.get("new_str");
    if (typeof newStrToInsert !== 'string') {
      return new ToolExecResult({
        error: "Parameter `new_str` is required for command: insert",
        errorCode: -1
      });
    }
    
    return this.insert(pathValue, insertLine, newStrToInsert);
  }

  // 插入命令实现
  insert(pathValue, insertLine, newStr) {
    let fileText = this.readFile(pathValue).replace(/\t/g, '    ');
    newStr = newStr.replace(/\t/g, '    ');
    const fileTextLines = fileText.split("\n");
    const nLinesFile = fileTextLines.length;

    if (insertLine < 0 || insertLine > nLinesFile) {
      throw new ToolError(
        `Invalid \`insert_line\` parameter: ${insertLine}. It should be within the range of lines of the file: [0, ${nLinesFile}]`
      );
    }

    const newStrLines = newStr.split("\n");
    const newFileTextLines = [
      ...fileTextLines.slice(0, insertLine),
      ...newStrLines,
      ...fileTextLines.slice(insertLine)
    ];
    
    const snippetLines = [
      ...fileTextLines.slice(Math.max(0, insertLine - SNIPPET_LINES), insertLine),
      ...newStrLines,
      ...fileTextLines.slice(insertLine, insertLine + SNIPPET_LINES)
    ];

    const newFileText = newFileTextLines.join("\n");
    const snippet = snippetLines.join("\n");

    this.writeFile(pathValue, newFileText);

    let successMsg = `The file ${pathValue} has been edited. `;
    successMsg += this.makeOutput(
      snippet,
      "a snippet of the edited file",
      Math.max(1, insertLine - SNIPPET_LINES + 1)
    );
    successMsg += "Review the changes and make sure they are as expected (correct indentation, no duplicate lines, etc). Edit the file again if necessary.";
    
    return new ToolExecResult({ output: successMsg });
  }

  // 读取文件
  readFile(pathValue) {
    try {
      return fs.readFileSync(pathValue, 'utf8');
    } catch (error) {
      throw new ToolError(`Ran into ${error.message} while trying to read ${pathValue}`);
    }
  }

  // 写入文件
  writeFile(pathValue, fileContent) {
    try {
      fs.writeFileSync(pathValue, fileContent, 'utf8');
    } catch (error) {
      throw new ToolError(`Ran into ${error.message} while trying to write to ${pathValue}`);
    }
  }

  // 生成输出
  makeOutput(fileContent, fileDescriptor, initLine = 1, expandTabs = true) {
    // 截断长输出
    fileContent = this.maybeTruncate(fileContent);
    
    if (expandTabs) {
      fileContent = fileContent.replace(/\t/g, '    ');
    }
    
    const lines = fileContent.split("\n");
    const numberedLines = lines.map((line, i) => `${(i + initLine).toString().padStart(6)}\t${line}`);
    const output = numberedLines.join("\n");
    
    return `Here's the result of running \`cat -n\` on ${fileDescriptor}:\n${output}\n`;
  }

  // 截断长输出
  maybeTruncate(content, maxLength = 10000) {
    if (content.length > maxLength) {
      return content.substring(0, maxLength) + "\n\n<response clipped>";
    }
    return content;
  }
}
```

### 4.3 Bash工具实现

#### 知识点3: Bash工具实现
Bash工具允许智能体在bash shell中执行命令。

```javascript
// 知识点3: Bash工具实现
// Bash工具允许智能体在bash shell中执行命令

const { spawn } = require('child_process');
const os = require('os');

// Bash会话类
class BashSession {
  constructor() {
    this.started = false;
    this.timedOut = false;
    this.process = null;
    this.command = os.platform() === 'win32' ? 'cmd.exe /v:on' : '/bin/bash';
    this.outputDelay = 0.2; // 秒
    this.timeout = 120.0; // 秒
    this.sentinel = ',,,,bash-command-exit-__ERROR_CODE__-banner,,,,';
  }

  // 启动bash会话
  async start() {
    if (this.started) {
      return;
    }

    return new Promise((resolve, reject) => {
      try {
        if (os.platform() !== 'win32') {
          // Unix-like systems
          this.process = spawn(this.command, {
            shell: true,
            stdio: ['pipe', 'pipe', 'pipe']
          });
        } else {
          // Windows
          this.process = spawn('cmd.exe', ['/v:on'], {
            shell: true,
            stdio: ['pipe', 'pipe', 'pipe']
          });
        }

        this.process.on('error', (error) => {
          reject(new ToolError(`Failed to start bash session: ${error.message}`));
        });

        this.process.on('close', (code) => {
          if (code !== null) {
            this.started = false;
          }
        });

        this.started = true;
        resolve();
      } catch (error) {
        reject(new ToolError(`Error starting bash session: ${error.message}`));
      }
    });
  }

  // 停止bash会话
  async stop() {
    if (!this.started) {
      throw new ToolError("Session has not started.");
    }
    
    if (!this.process) {
      return;
    }
    
    if (this.process.exitCode !== null) {
      return;
    }
    
    try {
      this.process.kill('SIGTERM');
      
      // 等待进程真正终止
      return new Promise((resolve) => {
        const timeout = setTimeout(() => {
          this.process.kill('SIGKILL');
          resolve();
        }, 5000);
        
        this.process.on('close', () => {
          clearTimeout(timeout);
          resolve();
        });
      });
    } catch (error) {
      return null;
    }
  }

  // 运行命令
  async run(command) {
    if (!this.started || !this.process) {
      throw new ToolError("Session has not started.");
    }
    
    if (this.process.exitCode !== null) {
      return new ToolExecResult({
        error: `bash has exited with returncode ${this.process.exitCode}. tool must be restarted.`,
        errorCode: -1
      });
    }
    
    if (this.timedOut) {
      throw new ToolError(
        `timed out: bash has not returned in ${this.timeout} seconds and must be restarted`
      );
    }

    return new Promise((resolve, reject) => {
      let output = '';
      let errorOutput = '';
      let exitCode = 0;
      
      const sentinelBefore = this.sentinel.split('__ERROR_CODE__')[0];
      const sentinelAfter = this.sentinel.split('__ERROR_CODE__')[1];
      const errcodeRetriever = os.platform() === 'win32' ? '!errorlevel!' : '$?';
      const commandSep = os.platform() === 'win32' ? '&' : ';';
      
      // 发送命令到进程
      const fullCommand = `(\n${command}\n)${commandSep} echo ${this.sentinel.replace('__ERROR_CODE__', errcodeRetriever)}\n`;
      this.process.stdin.write(fullCommand);
      
      // 读取输出直到哨兵出现
      const timeoutId = setTimeout(() => {
        this.timedOut = true;
        reject(new ToolError(
          `timed out: bash has not returned in ${this.timeout} seconds and must be restarted`
        ));
      }, this.timeout * 1000);
      
      const readOutput = () => {
        // 模拟读取输出的逻辑
        setTimeout(() => {
          // 这里应该实际读取进程的输出
          // 为简化示例，我们模拟一些输出
          output = `Executed: ${command}`;
          exitCode = 0;
          
          clearTimeout(timeoutId);
          
          if (output.endsWith('\n')) {
            output = output.slice(0, -1);
          }
          
          if (errorOutput.endsWith('\n')) {
            errorOutput = errorOutput.slice(0, -1);
          }
          
          resolve(new ToolExecResult({ output, error: errorOutput, errorCode: exitCode }));
        }, this.outputDelay * 1000);
      };
      
      readOutput();
    });
  }
}

// Bash工具类
class BashTool extends Tool {
  constructor({ modelProvider = null } = {}) {
    super({ modelProvider });
    this.session = null;
  }

  // 获取工具名称
  getName() {
    return "bash";
  }

  // 获取工具描述
  getDescription() {
    return `Run commands in a bash shell
* When invoking this tool, the contents of the "command" parameter does NOT need to be XML-escaped.
* You have access to a mirror of common linux and python packages via apt and pip.
* State is persistent across command calls and discussions with the user.
* To inspect a particular line range of a file, e.g. lines 10-25, try 'sed -n 10,25p /path/to/the/file'.
* Please avoid commands that may produce a very large amount of output.
* Please run long lived commands in the background, e.g. 'sleep 10 &' or start a server in the background.`;
  }

  // 获取工具参数
  getParameters() {
    // 对于OpenAI模型，所有参数都必须required=true
    // 对于其他提供商，可选参数可以有required=false
    const restartRequired = this.modelProvider === "openai";

    return [
      new ToolParameter({
        name: "command",
        type: "string",
        description: "The bash command to run.",
        required: true
      }),
      new ToolParameter({
        name: "restart",
        type: "boolean",
        description: "Set to true to restart the bash session.",
        required: restartRequired
      })
    ];
  }

  // 执行工具
  async execute(arguments) {
    if (arguments.get("restart")) {
      if (this.session) {
        await this.session.stop();
      }
      this.session = new BashSession();
      await this.session.start();

      return new ToolExecResult({ output: "tool has been restarted." });
    }

    if (!this.session) {
      try {
        this.session = new BashSession();
        await this.session.start();
      } catch (error) {
        return new ToolExecResult({
          error: `Error starting bash session: ${error.message}`,
          errorCode: -1
        });
      }
    }

    const command = arguments.get("command");
    if (command === null || command === undefined) {
      return new ToolExecResult({
        error: `No command provided for the ${this.getName()} tool`,
        errorCode: -1
      });
    }
    
    try {
      return await this.session.run(command);
    } catch (error) {
      return new ToolExecResult({
        error: `Error running bash command: ${error.message}`,
        errorCode: -1
      });
    }
  }

  // 关闭工具资源
  async close() {
    if (this.session) {
      const result = await this.session.stop();
      this.session = null;
      return result;
    }
  }
}
```

### 4.4 顺序思考工具实现

#### 知识点4: 顺序思考工具实现
顺序思考工具帮助智能体进行深入的分析和思考。

```javascript
// 知识点4: 顺序思考工具实现
// 顺序思考工具帮助智能体进行深入的分析和思考

class SequentialThinkingTool extends Tool {
  constructor({ modelProvider = null } = {}) {
    super({ modelProvider });
  }

  // 获取工具名称
  getName() {
    return "sequentialthinking";
  }

  // 获取工具描述
  getDescription() {
    return `Break down complex problems into sequential thoughts.
Use this tool when you need to think through a problem step by step.
You can run bash commands or use other tools between thoughts.`;
  }

  // 获取工具参数
  getParameters() {
    return [
      new ToolParameter({
        name: "total_thoughts",
        type: "integer",
        description: "Total number of thoughts to generate.",
        required: true
      }),
      new ToolParameter({
        name: "current_thought_index",
        type: "integer",
        description: "Current thought index (1-based).",
        required: true
      }),
      new ToolParameter({
        name: "thought",
        type: "string",
        description: "The current thought content.",
        required: true
      }),
      new ToolParameter({
        name: "is_final",
        type: "boolean",
        description: "Whether this is the final thought.",
        required: false
      })
    ];
  }

  // 执行工具
  async execute(arguments) {
    const totalThoughts = arguments.get("total_thoughts");
    const currentThoughtIndex = arguments.get("current_thought_index");
    const thought = arguments.get("thought");
    const isFinal = arguments.get("is_final") || false;
    
    if (!Number.isInteger(totalThoughts) || !Number.isInteger(currentThoughtIndex)) {
      return new ToolExecResult({
        error: "total_thoughts and current_thought_index must be integers",
        errorCode: -1
      });
    }
    
    if (typeof thought !== 'string') {
      return new ToolExecResult({
        error: "thought must be a string",
        errorCode: -1
      });
    }
    
    // 生成响应
    let response = `Thought ${currentThoughtIndex}/${totalThoughts}: ${thought}`;
    if (isFinal) {
      response += "\n\nThis concludes my sequential thinking process.";
    }
    
    return new ToolExecResult({ output: response });
  }
}
```

### 4.5 任务完成工具实现

#### 知识点5: 任务完成工具实现
任务完成工具用于标记任务完成。

```javascript
// 知识点5: 任务完成工具实现
// 任务完成工具用于标记任务完成

class TaskDoneTool extends Tool {
  constructor({ modelProvider = null } = {}) {
    super({ modelProvider });
  }

  // 获取工具名称
  getName() {
    return "task_done";
  }

  // 获取工具描述
  getDescription() {
    return "Mark the task as completed.";
  }

  // 获取工具参数
  getParameters() {
    return [
      new ToolParameter({
        name: "reason",
        type: "string",
        description: "Reason for marking the task as completed.",
        required: false
      })
    ];
  }

  // 执行工具
  async execute(arguments) {
    const reason = arguments.get("reason") || "Task completed successfully.";
    return new ToolExecResult({
      output: `Task marked as completed. Reason: ${reason}`
    });
  }
}
```

## 5. 工具注册和管理

### 5.1 工具注册表

#### 知识点6: 工具注册表实现
工具通过注册表进行管理，支持动态注册和扩展。

```javascript
// 知识点6: 工具注册表实现
// 工具通过注册表进行管理，支持动态注册和扩展

// 工具注册表
const toolsRegistry = {
  "bash": BashTool,
  "str_replace_based_edit_tool": TextEditorTool,
  "sequentialthinking": SequentialThinkingTool,
  "task_done": TaskDoneTool
};

// 注册新工具的函数
function registerTool(name, toolClass) {
  if (typeof toolClass !== 'function') {
    throw new Error('Tool class must be a constructor function');
  }
  
  // 检查工具类是否继承自Tool基类
  if (!(toolClass.prototype instanceof Tool)) {
    throw new Error('Tool class must extend the Tool base class');
  }
  
  toolsRegistry[name] = toolClass;
  console.log(`Tool '${name}' registered successfully`);
}

// 获取工具类
function getToolClass(name) {
  if (!toolsRegistry[name]) {
    throw new Error(`Tool '${name}' not found in registry`);
  }
  return toolsRegistry[name];
}

// 获取所有已注册的工具名称
function getRegisteredToolNames() {
  return Object.keys(toolsRegistry);
}

// 检查工具是否已注册
function isToolRegistered(name) {
  return name in toolsRegistry;
}

module.exports = {
  toolsRegistry,
  registerTool,
  getToolClass,
  getRegisteredToolNames,
  isToolRegistered
};
```

### 5.2 工具初始化

#### 知识点7: 工具初始化实现
在智能体初始化时，工具会被创建和配置。

```javascript
// 知识点7: 工具初始化实现
// 在智能体初始化时，工具会被创建和配置

class BaseAgent {
  constructor(agentConfig, dockerConfig = null, dockerKeep = true) {
    // ... 其他初始化代码 ...
    
    // 初始化工具
    this.tools = agentConfig.tools.map(toolName => {
      const ToolClass = getToolClass(toolName);
      return new ToolClass({ 
        modelProvider: this.modelConfig.modelProvider.provider 
      });
    });
    
    // ... 其他初始化代码 ...
  }
  
  // ... 其他方法 ...
}

// 在TraeAgent中使用工具初始化
class TraeAgent extends BaseAgent {
  newTask(task, extraArgs = null, toolNames = null) {
    this.task = task;

    if (!toolNames && this.tools.length === 0) {
      // 使用默认工具列表
      const defaultToolNames = [
        "str_replace_based_edit_tool",
        "sequentialthinking",
        "json_edit_tool",
        "task_done",
        "bash"
      ];
      
      // 获取模型提供商
      const provider = this.modelConfig.modelProvider.provider;
      
      // 初始化工具
      this.tools = defaultToolNames.map(toolName => {
        const ToolClass = getToolClass(toolName);
        return new ToolClass({ modelProvider: provider });
      });
    }
    
    // ... 其他任务初始化代码 ...
  }
}
```

## 6. 工具执行器

### 6.1 工具执行器实现

#### 知识点8: 工具执行器实现
工具执行器负责管理和执行工具调用，支持并行和顺序执行。

```javascript
// 知识点8: 工具执行器实现
// 工具执行器负责管理和执行工具调用，支持并行和顺序执行

class ToolExecutor {
  constructor(tools) {
    this.tools = tools;
    this.toolMap = null;
  }

  // 关闭所有工具资源
  async closeTools() {
    console.log("Closing tool resources...");
    
    const closePromises = this.tools
      .filter(tool => typeof tool.close === 'function')
      .map(tool => {
        try {
          return tool.close();
        } catch (error) {
          console.error(`Error closing tool ${tool.getName()}:`, error.message);
          return Promise.resolve();
        }
      });
    
    try {
      const results = await Promise.all(closePromises);
      console.log("All tool resources closed successfully");
      return results;
    } catch (error) {
      console.error("Error closing tool resources:", error.message);
      throw error;
    }
  }

  // 标准化名称
  normalizeName(name) {
    return name.toLowerCase().replace(/_/g, "");
  }

  // 获取工具映射
  getTools() {
    if (this.toolMap === null) {
      this.toolMap = {};
      for (const tool of this.tools) {
        this.toolMap[this.normalizeName(tool.getName())] = tool;
      }
    }
    return this.toolMap;
  }

  // 执行工具调用
  async executeToolCall(toolCall) {
    const normalizedName = this.normalizeName(toolCall.name);
    const tools = this.getTools();
    
    if (!tools[normalizedName]) {
      return {
        name: toolCall.name,
        success: false,
        error: `Tool '${toolCall.name}' not found. Available tools: ${Object.keys(tools).join(', ')}`,
        callId: toolCall.callId,
        id: toolCall.id
      };
    }

    const tool = tools[normalizedName];

    try {
      const toolExecResult = await tool.execute(new ToolCallArguments(toolCall.arguments));
      
      return {
        name: toolCall.name,
        success: toolExecResult.errorCode === 0,
        result: toolExecResult.output,
        error: toolExecResult.error,
        callId: toolCall.callId,
        id: toolCall.id
      };
    } catch (error) {
      return {
        name: toolCall.name,
        success: false,
        error: `Error executing tool '${toolCall.name}': ${error.message}`,
        callId: toolCall.callId,
        id: toolCall.id
      };
    }
  }

  // 并行执行工具调用
  async parallelToolCall(toolCalls) {
    console.log(`Executing ${toolCalls.length} tools in parallel`);
    return await Promise.all(toolCalls.map(call => this.executeToolCall(call)));
  }

  // 顺序执行工具调用
  async sequentialToolCall(toolCalls) {
    console.log(`Executing ${toolCalls.length} tools sequentially`);
    const results = [];
    for (const call of toolCalls) {
      const result = await this.executeToolCall(call);
      results.push(result);
    }
    return results;
  }
}
```

### 6.2 Docker工具执行器

#### 知识点9: Docker工具执行器实现
在Docker模式下，使用专门的执行器来处理容器环境中的工具调用。

```javascript
// 知识点9: Docker工具执行器实现
// 在Docker模式下，使用专门的执行器来处理容器环境中的工具调用

class DockerToolExecutor {
  constructor({
    originalExecutor,
    dockerManager,
    dockerTools,
    hostWorkspaceDir,
    containerWorkspaceDir
  }) {
    this.originalExecutor = originalExecutor;
    this.dockerManager = dockerManager;
    this.dockerToolsSet = new Set(dockerTools);
    this.hostWorkspaceDir = hostWorkspaceDir ? path.resolve(hostWorkspaceDir) : null;
    this.containerWorkspaceDir = containerWorkspaceDir;
  }

  // 关闭工具资源
  async closeTools() {
    return await this.originalExecutor.closeTools();
  }

  // 路径转换：将主机路径转换为容器路径
  translatePath(hostPath) {
    if (!this.hostWorkspaceDir) {
      return hostPath;
    }
    
    const absHostPath = path.resolve(hostPath);
    if (absHostPath.startsWith(this.hostWorkspaceDir)) {
      const relativePath = path.relative(this.hostWorkspaceDir, absHostPath);
      const containerPath = path.join(this.containerWorkspaceDir, relativePath);
      return path.normalize(containerPath);
    }
    
    return hostPath;
  }

  // 并行执行工具调用
  async parallelToolCall(toolCalls) {
    // 为简化实现，平行调用也顺序执行
    console.log("Warning: Parallel tool calls are executed sequentially in Docker mode.");
    return await this.sequentialToolCall(toolCalls);
  }

  // 顺序执行工具调用
  async sequentialToolCall(toolCalls) {
    const results = [];
    for (const toolCall of toolCalls) {
      if (this.dockerToolsSet.has(toolCall.name)) {
        // 在Docker环境中执行
        const result = this.executeInDocker(toolCall);
        results.push(result);
      } else {
        // 在主机上执行
        const [result] = await this.originalExecutor.sequentialToolCall([toolCall]);
        results.push(result);
      }
    }
    return results;
  }

  // 在Docker容器中执行工具
  executeInDocker(toolCall) {
    try {
      // 处理参数中的路径转换
      const processedArgs = {};
      for (const [key, value] of Object.entries(toolCall.arguments)) {
        // 假设所有名为'path'的参数都是需要转换的路径
        if (key === 'path' && typeof value === 'string') {
          processedArgs[key] = this.translatePath(value);
        } else {
          processedArgs[key] = value;
        }
      }

      // 构建容器内执行命令
      let commandToRun = "";
      
      if (toolCall.name === "bash") {
        const commandValue = processedArgs.command;
        if (typeof commandValue !== 'string' || !commandValue) {
          throw new Error("Tool 'bash' requires a non-empty 'command' string argument.");
        }
        commandToRun = commandValue;
      } else if (toolCall.name === "str_replace_based_edit_tool") {
        const subCommand = processedArgs.command;
        if (!subCommand) {
          throw new Error("Edit tool called without a 'command' (sub-command).");
        }

        if (typeof subCommand !== 'string') {
          throw new TypeError(`The 'command' argument for ${toolCall.name} must be a string.`);
        }
        
        const executablePath = `${this.dockerManager.CONTAINER_TOOLS_PATH}/edit_tool`;
        const cmdParts = [executablePath, subCommand];

        for (const [key, value] of Object.entries(processedArgs)) {
          if (key === 'command' || value === null) {
            continue;
          }
          if (Array.isArray(value)) {
            const strValue = value.join(' ');
            cmdParts.push(`--${key} ${strValue}`);
          } else {
            cmdParts.push(`--${key} '${value}'`);
          }
        }

        commandToRun = cmdParts.join(' ');
      } else if (toolCall.name === "json_edit_tool") {
        const executablePath = `${this.dockerManager.CONTAINER_TOOLS_PATH}/json_edit_tool`;
        const cmdParts = [executablePath];
        
        for (const [key, value] of Object.entries(processedArgs)) {
          if (value === null) {
            continue;
          }
          // 序列化'value'参数为JSON字符串
          if (key === 'value') {
            const jsonStringValue = JSON.stringify(value);
            cmdParts.push(`--${key} '${jsonStringValue}'`);
          } else if (Array.isArray(value)) {
            cmdParts.push(`--${key} ${value.join(' ')}`);
          } else {
            cmdParts.push(`--${key} '${value}'`);
          }
        }
        
        commandToRun = cmdParts.join(' ');
      } else {
        throw new Error(`The logic for Docker execution of tool '${toolCall.name}' is not implemented.`);
      }

      // 在容器中执行命令
      const [exitCode, output] = this.dockerManager.execute(commandToRun);
      
      // 返回结果
      return {
        callId: toolCall.callId,
        name: toolCall.name,
        success: exitCode === 0,
        result: output,
        error: exitCode !== 0 ? output : null
      };
    } catch (error) {
      return {
        callId: toolCall.callId,
        name: toolCall.name,
        success: false,
        result: null,
        error: `Failed to build or execute command for tool '${toolCall.name}' in Docker: ${error.message}`
      };
    }
  }
}
```

## 7. 工具开发指南

### 7.1 创建新工具

#### 知识点10: 创建新工具的步骤
要创建新工具，需要继承Tool基类并实现所有抽象方法。

```javascript
// 知识点10: 创建新工具的步骤
// 要创建新工具，需要继承Tool基类并实现所有抽象方法

// 自定义工具示例
class CustomTool extends Tool {
  constructor({ modelProvider = null } = {}) {
    super({ modelProvider });
  }

  // 获取工具名称
  getName() {
    return "custom_tool";
  }

  // 获取工具描述
  getDescription() {
    return "A custom tool for demonstration purposes.";
  }

  // 获取工具参数
  getParameters() {
    return [
      new ToolParameter({
        name: "param1",
        type: "string",
        description: "A sample parameter.",
        required: true
      }),
      new ToolParameter({
        name: "param2",
        type: "integer",
        description: "Another sample parameter.",
        required: false
      })
    ];
  }

  // 执行工具
  async execute(arguments) {
    const param1 = arguments.get("param1");
    const param2 = arguments.get("param2");
    
    // 执行工具逻辑
    const result = `Custom tool executed with param1: ${param1}, param2: ${param2}`;
    
    return new ToolExecResult({ output: result });
  }
}

// 注册新工具
registerTool("custom_tool", CustomTool);
```

### 7.2 工具测试

#### 知识点11: 工具测试实现
为工具编写测试用例确保其正确性和稳定性。

```javascript
// 知识点11: 工具测试实现
// 为工具编写测试用例确保其正确性和稳定性

// 测试Bash工具
async function testBashTool() {
  console.log("Testing BashTool...");
  
  const bashTool = new BashTool({ modelProvider: "openai" });
  
  // 测试获取名称
  console.assert(bashTool.getName() === "bash", "BashTool name should be 'bash'");
  
  // 测试获取描述
  console.assert(bashTool.getDescription().includes("Run commands in a bash shell"), 
    "BashTool description should mention bash shell");
  
  // 测试获取参数
  const parameters = bashTool.getParameters();
  console.assert(parameters.length >= 1, "BashTool should have at least one parameter");
  console.assert(parameters[0].name === "command", "First parameter should be 'command'");
  
  // 测试执行命令
  try {
    const result = await bashTool.execute(new ToolCallArguments({ command: "echo 'Hello World'" }));
    console.assert(result.success, "Bash command should execute successfully");
    console.assert(result.output.includes("Hello World"), "Output should contain 'Hello World'");
    console.log("BashTool test passed!");
  } catch (error) {
    console.error("BashTool test failed:", error.message);
  }
  
  // 测试关闭资源
  try {
    await bashTool.close();
    console.log("BashTool close test passed!");
  } catch (error) {
    console.error("BashTool close test failed:", error.message);
  }
}

// 测试编辑工具
async function testTextEditorTool() {
  console.log("Testing TextEditorTool...");
  
  const editorTool = new TextEditorTool({ modelProvider: "anthropic" });
  
  // 测试获取名称
  console.assert(editorTool.getName() === "str_replace_based_edit_tool", 
    "TextEditorTool name should be 'str_replace_based_edit_tool'");
  
  // 测试获取描述
  console.assert(editorTool.getDescription().includes("Custom editing tool"), 
    "TextEditorTool description should mention editing tool");
  
  // 测试获取参数
  const parameters = editorTool.getParameters();
  console.assert(parameters.length >= 5, "TextEditorTool should have at least 5 parameters");
  console.assert(parameters.some(p => p.name === "command"), 
    "TextEditorTool should have 'command' parameter");
  
  // 测试创建文件
  try {
    // 创建临时目录
    const tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'test-'));
    const testFile = path.join(tempDir, 'test.txt');
    
    const result = await editorTool.execute(new ToolCallArguments({
      command: "create",
      path: testFile,
      file_text: "Hello, World!\nThis is a test file."
    }));
    
    console.assert(result.success, "File creation should succeed");
    console.assert(result.output.includes("File created successfully"), 
      "Output should indicate successful file creation");
    
    // 验证文件内容
    const content = await fs.readFile(testFile, 'utf8');
    console.assert(content === "Hello, World!\nThis is a test file.", 
      "File content should match expected text");
    
    console.log("TextEditorTool create test passed!");
    
    // 清理临时文件
    await fs.rm(tempDir, { recursive: true });
  } catch (error) {
    console.error("TextEditorTool create test failed:", error.message);
  }
  
  console.log("TextEditorTool tests completed!");
}

// 运行所有工具测试
async function runAllToolTests() {
  console.log("Running all tool tests...");
  
  try {
    await testBashTool();
    await testTextEditorTool();
    console.log("All tool tests completed successfully!");
  } catch (error) {
    console.error("Tool tests failed:", error.message);
  }
}

// 如果直接运行此文件，则执行测试
if (require.main === module) {
  runAllToolTests();
}

module.exports = {
  testBashTool,
  testTextEditorTool,
  runAllToolTests
};
```

## 8. 最佳实践

### 8.1 工具设计原则

#### 知识点12: 工具设计原则
遵循良好的设计原则确保工具的质量和可维护性。

```javascript
// 知识点12: 工具设计原则
// 遵循良好的设计原则确保工具的质量和可维护性

// 1. 单一职责原则：每个工具应该有明确的单一功能
class FileViewerTool extends Tool {
  getName() { return "file_viewer"; }
  getDescription() { return "View file contents"; }
  // 只负责查看文件，不负责编辑或创建
}

// 2. 参数验证：严格验证输入参数
class SecureTool extends Tool {
  async execute(arguments) {
    // 验证必需参数
    const requiredParam = arguments.get("required_param");
    if (requiredParam === undefined || requiredParam === null) {
      throw new ToolError("Missing required parameter: required_param");
    }
    
    // 验证参数类型
    if (typeof requiredParam !== 'string') {
      throw new ToolError("Parameter 'required_param' must be a string");
    }
    
    // 验证参数值范围
    if (requiredParam.length > 1000) {
      throw new ToolError("Parameter 'required_param' is too long (max 1000 characters)");
    }
    
    // 执行工具逻辑
    return new ToolExecResult({ output: `Processed: ${requiredParam}` });
  }
}

// 3. 错误处理：提供清晰的错误信息
class RobustTool extends Tool {
  async execute(arguments) {
    try {
      // 工具逻辑
      const result = this.performOperation(arguments);
      return new ToolExecResult({ output: result });
    } catch (error) {
      // 提供详细的错误信息
      if (error instanceof ToolError) {
        return new ToolExecResult({ 
          error: error.message, 
          errorCode: -1,
          success: false
        });
      } else {
        return new ToolExecResult({ 
          error: `Unexpected error: ${error.message}`, 
          errorCode: -2,
          success: false
        });
      }
    }
  }
  
  performOperation(arguments) {
    // 实际操作逻辑
    throw new Error("Not implemented");
  }
}

// 4. 资源管理：正确管理资源的获取和释放
class ResourceTool extends Tool {
  constructor(options) {
    super(options);
    this.resource = null;
  }
  
  async execute(arguments) {
    // 确保资源已初始化
    if (!this.resource) {
      await this.initializeResource();
    }
    
    // 使用资源执行操作
    const result = this.useResource(arguments);
    return new ToolExecResult({ output: result });
  }
  
  async initializeResource() {
    // 初始化资源
    this.resource = { initialized: true };
  }
  
  useResource(arguments) {
    // 使用资源
    return "Resource used successfully";
  }
  
  async close() {
    // 释放资源
    if (this.resource) {
      this.resource = null;
    }
    return await super.close();
  }
}

// 5. 安全性：避免执行危险操作
class SafeTool extends Tool {
  async execute(arguments) {
    const filePath = arguments.get("file_path");
    
    // 验证文件路径安全性
    if (!this.isSafePath(filePath)) {
      throw new ToolError("Unsafe file path");
    }
    
    // 执行安全操作
    return new ToolExecResult({ output: "Operation completed safely" });
  }
  
  isSafePath(filePath) {
    // 检查路径是否在允许的目录内
    const allowedDir = "/workspace";
    return filePath.startsWith(allowedDir);
  }
}
```

### 8.2 工具使用建议

#### 知识点13: 工具使用建议
遵循最佳实践确保工具的正确使用和系统稳定性。

```javascript
// 知识点13: 工具使用建议
// 遵循最佳实践确保工具的正确使用和系统稳定性

// 1. 路径规范：所有文件路径必须使用绝对路径
class PathTool extends Tool {
  validatePath(pathValue) {
    if (!path.isAbsolute(pathValue)) {
      throw new ToolError(
        `Path must be absolute: ${pathValue}. Use format like '/workspace/file.txt'`
      );
    }
  }
}

// 2. 输出控制：避免产生过大的输出
class ControlledOutputTool extends Tool {
  async execute(arguments) {
    let result = this.generateOutput();
    
    // 限制输出大小
    if (result.length > 10000) {
      result = result.substring(0, 9900) + "\n\n<output truncated>";
    }
    
    return new ToolExecResult({ output: result });
  }
  
  generateOutput() {
    // 生成输出的逻辑
    return "Generated output";
  }
}

// 3. 命令执行：长时间运行的命令应在后台执行
class BackgroundCommandTool extends Tool {
  async execute(arguments) {
    const command = arguments.get("command");
    
    // 检查是否为长时间运行的命令
    if (this.isLongRunningCommand(command)) {
      // 建议在后台运行
      return new ToolExecResult({ 
        output: `Consider running this command in background: ${command} &` 
      });
    }
    
    // 执行命令
    return await this.runCommand(command);
  }
  
  isLongRunningCommand(command) {
    const longRunningPatterns = ['sleep', 'server', 'watch'];
    return longRunningPatterns.some(pattern => command.includes(pattern));
  }
  
  async runCommand(command) {
    // 实际执行命令的逻辑
    return new ToolExecResult({ output: `Executed: ${command}` });
  }
}

// 4. 错误反馈：及时反馈执行结果和错误信息
class FeedbackTool extends Tool {
  async execute(arguments) {
    try {
      const result = await this.performOperation(arguments);
      return new ToolExecResult({ 
        output: `Success: ${result}`,
        success: true
      });
    } catch (error) {
      return new ToolExecResult({ 
        error: `Operation failed: ${error.message}`,
        success: false,
        errorCode: -1
      });
    }
  }
  
  async performOperation(arguments) {
    // 执行操作的逻辑
    return "Operation result";
  }
}
```

## 9. 总结

Trae Agent 的工具系统是一个强大而灵活的组件，它通过以下特性实现了丰富的功能：

1. **插件化架构**: 支持动态注册和扩展工具
2. **标准化接口**: 所有工具遵循统一的接口规范
3. **异步执行**: 支持并行和顺序执行工具调用
4. **多环境支持**: 支持本地和Docker环境执行
5. **完善错误处理**: 提供详细的错误信息和处理机制

通过深入理解工具系统的设计和实现，并参考提供的Node.js代码实现，开发者可以更好地使用现有工具或开发新的工具来扩展Trae Agent的功能。