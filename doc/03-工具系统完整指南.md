# Trae Agent 工具系统完整指南

## 1. 工具系统概述

Trae Agent 的工具系统是其核心功能之一，它允许智能体执行各种操作来完成软件工程任务。工具系统采用插件化架构，支持动态注册和扩展，使得系统可以轻松添加新的工具功能。

## 2. 工具架构设计

### 2.1 工具基类

所有工具都继承自 `Tool` 基类，该基类定义了工具的基本接口：

```python
class Tool(ABC):
    def __init__(self, model_provider: str | None = None) -> None:
        self._model_provider = model_provider

    @abstractmethod
    def get_name(self) -> str:
        """获取工具名称"""
        pass

    @abstractmethod
    def get_description(self) -> str:
        """获取工具描述"""
        pass

    @abstractmethod
    def get_parameters(self) -> list[ToolParameter]:
        """获取工具参数定义"""
        pass

    @abstractmethod
    async def execute(self, arguments: ToolCallArguments) -> ToolExecResult:
        """执行工具"""
        pass

    async def close(self):
        """关闭工具资源"""
        pass
```

### 2.2 工具参数定义

工具参数通过 `ToolParameter` 类定义：

```python
@dataclass
class ToolParameter:
    name: str
    type: str
    description: str
    required: bool = False
    enum: list[str] | None = None
    items: dict[str, Any] | None = None
```

### 2.3 工具执行结果

工具执行结果通过 `ToolExecResult` 类表示：

```python
@dataclass
class ToolExecResult:
    output: str | None = None
    error: str | None = None
    error_code: int | None = None
    success: bool = True
```

## 3. 核心工具详解

### 3.1 编辑工具 (TextEditorTool)

编辑工具是Trae Agent中最核心的工具之一，它允许代理查看、创建和修改文件。

#### 3.1.1 工具功能

编辑工具支持以下子命令：
1. `view`: 查看文件或目录内容
2. `create`: 创建新文件
3. `str_replace`: 字符串替换
4. `insert`: 插入内容

#### 3.1.2 工具实现

```python
class TextEditorTool(Tool):
    def get_name(self) -> str:
        return "str_replace_based_edit_tool"

    def get_description(self) -> str:
        return """Custom editing tool for viewing, creating and editing files
* State is persistent across command calls and discussions with the user
* If `path` is a file, `view` displays the result of applying `cat -n`. If `path` is a directory, `view` lists non-hidden files and directories up to 2 levels deep
* The `create` command cannot be used if the specified `path` already exists as a file !!! If you know that the `path` already exists, please remove it first and then perform the `create` operation!
* If a `command` generates a long output, it will be truncated and marked with `<response clipped>`
"""

    def get_parameters(self) -> list[ToolParameter]:
        return [
            ToolParameter(
                name="command",
                type="string",
                description=f"The commands to run. Allowed options are: {', '.join(EditToolSubCommands)}.",
                required=True,
                enum=EditToolSubCommands,
            ),
            # ... 其他参数定义
        ]

    async def execute(self, arguments: ToolCallArguments) -> ToolExecResult:
        command = str(arguments["command"]) if "command" in arguments else None
        path = str(arguments["path"]) if "path" in arguments else None
        _path = Path(path)
        
        try:
            self.validate_path(command, _path)
            match command:
                case "view":
                    return await self._view_handler(arguments, _path)
                case "create":
                    return self._create_handler(arguments, _path)
                case "str_replace":
                    return self._str_replace_handler(arguments, _path)
                case "insert":
                    return self._insert_handler(arguments, _path)
                case _:
                    return ToolExecResult(
                        error=f"Unrecognized command {command}. The allowed commands for the {self.name} tool are: {', '.join(EditToolSubCommands)}",
                        error_code=-1,
                    )
        except ToolError as e:
            return ToolExecResult(error=str(e), error_code=-1)
```

#### 3.1.3 关键功能实现

1. **路径验证**:
```python
def validate_path(self, command: str, path: Path):
    """验证路径"""
    if not path.is_absolute():
        suggested_path = Path("/") / path
        raise ToolError(
            f"The path {path} is not an absolute path, it should start with `/`. Maybe you meant {suggested_path}?"
        )
    # 检查路径是否存在
    if not path.exists() and command != "create":
        raise ToolError(f"The path {path} does not exist. Please provide a valid path.")
    # 检查路径是否指向目录
    if path.is_dir() and command != "view":
        raise ToolError(
            f"The path {path} is a directory and only the `view` command can be used on directories"
        )
```

2. **查看功能**:
```python
async def _view(self, path: Path, view_range: list[int] | None = None) -> ToolExecResult:
    """实现查看命令"""
    if path.is_dir():
        # 查看目录内容
        return_code, stdout, stderr = await run(rf"find {path} -maxdepth 2 -not -path '*/\.*'")
        if not stderr:
            stdout = f"Here's the files and directories up to 2 levels deep in {path}, excluding hidden items:\n{stdout}\n"
        return ToolExecResult(error_code=return_code, output=stdout, error=stderr)
    
    # 查看文件内容
    file_content = self.read_file(path)
    init_line = 1
    if view_range:
        # 处理行范围
        file_lines = file_content.split("\n")
        n_lines_file = len(file_lines)
        init_line, final_line = view_range
        # ... 范围验证和内容提取
    
    return ToolExecResult(
        output=self._make_output(file_content, str(path), init_line=init_line)
    )
```

3. **字符串替换**:
```python
def str_replace(self, path: Path, old_str: str, new_str: str | None) -> ToolExecResult:
    """实现字符串替换命令"""
    # 读取文件内容
    file_content = self.read_file(path).expandtabs()
    old_str = old_str.expandtabs()
    new_str = new_str.expandtabs() if new_str is not None else ""

    # 检查old_str在文件中的唯一性
    occurrences = file_content.count(old_str)
    if occurrences == 0:
        raise ToolError(
            f"No replacement was performed, old_str `{old_str}` did not appear verbatim in {path}."
        )
    elif occurrences > 1:
        file_content_lines = file_content.split("\n")
        lines = [idx + 1 for idx, line in enumerate(file_content_lines) if old_str in line]
        raise ToolError(
            f"No replacement was performed. Multiple occurrences of old_str `{old_str}` in lines {lines}. Please ensure it is unique"
        )

    # 执行替换
    new_file_content = file_content.replace(old_str, new_str)
    self.write_file(path, new_file_content)

    # 创建编辑片段
    replacement_line = file_content.split(old_str)[0].count("\n")
    start_line = max(0, replacement_line - SNIPPET_LINES)
    end_line = replacement_line + SNIPPET_LINES + new_str.count("\n")
    snippet = "\n".join(new_file_content.split("\n")[start_line : end_line + 1])

    # 准备成功消息
    success_msg = f"The file {path} has been edited. "
    success_msg += self._make_output(snippet, f"a snippet of {path}", start_line + 1)
    success_msg += "Review the changes and make sure they are as expected. Edit the file again if necessary."

    return ToolExecResult(output=success_msg)
```

### 3.2 Bash工具 (BashTool)

Bash工具允许智能体在bash shell中执行命令。

#### 3.2.1 工具实现

```python
class BashTool(Tool):
    def get_name(self) -> str:
        return "bash"

    def get_description(self) -> str:
        return """Run commands in a bash shell
* When invoking this tool, the contents of the "command" parameter does NOT need to be XML-escaped.
* You have access to a mirror of common linux and python packages via apt and pip.
* State is persistent across command calls and discussions with the user.
* To inspect a particular line range of a file, e.g. lines 10-25, try 'sed -n 10,25p /path/to/the/file'.
* Please avoid commands that may produce a very large amount of output.
* Please run long lived commands in the background, e.g. 'sleep 10 &' or start a server in the background.
"""

    def get_parameters(self) -> list[ToolParameter]:
        return [
            ToolParameter(
                name="command",
                type="string",
                description="The bash command to run.",
                required=True,
            ),
            ToolParameter(
                name="restart",
                type="boolean",
                description="Set to true to restart the bash session.",
                required=False,
            ),
        ]

    async def execute(self, arguments: ToolCallArguments) -> ToolExecResult:
        if arguments.get("restart"):
            # 重启会话
            if self._session:
                await self._session.stop()
            self._session = _BashSession()
            await self._session.start()
            return ToolExecResult(output="tool has been restarted.")

        # 启动会话（如果需要）
        if self._session is None:
            try:
                self._session = _BashSession()
                await self._session.start()
            except Exception as e:
                return ToolExecResult(error=f"Error starting bash session: {e}", error_code=-1)

        command = str(arguments["command"]) if "command" in arguments else None
        if command is None:
            return ToolExecResult(
                error=f"No command provided for the {self.get_name()} tool",
                error_code=-1,
            )
        try:
            return await self._session.run(command)
        except Exception as e:
            return ToolExecResult(error=f"Error running bash command: {e}", error_code=-1)
```

#### 3.2.2 Bash会话管理

```python
class _BashSession:
    def __init__(self) -> None:
        self._started = False
        self._timed_out = False
        self._process: asyncio.subprocess.Process | None = None

    async def start(self) -> None:
        """启动bash会话"""
        if self._started:
            return

        # 根据操作系统启动不同的shell
        if os.name != "nt":  # Unix-like systems
            self._process = await asyncio.create_subprocess_shell(
                self.command,
                shell=True,
                bufsize=0,
                stdin=asyncio.subprocess.PIPE,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                preexec_fn=os.setsid,
            )
        else:
            self._process = await asyncio.create_subprocess_shell(
                "cmd.exe /v:on",
                shell=True,
                bufsize=0,
                stdin=asyncio.subprocess.PIPE,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
            )

        self._started = True

    async def run(self, command: str) -> ToolExecResult:
        """执行命令"""
        if not self._started or self._process is None:
            raise ToolError("Session has not started.")
        
        # 发送命令到进程
        sentinel_before, pivot, sentinel_after = self._sentinel.partition("__ERROR_CODE__")
        errcode_retriever = "!errorlevel!" if os.name == "nt" else "$?"
        command_sep = "&" if os.name == "nt" else ";"
        
        self._process.stdin.write(
            b"(\n"
            + command.encode()
            + f"\n){command_sep} echo {self._sentinel.replace('__ERROR_CODE__', errcode_retriever)}\n".encode()
        )
        await self._process.stdin.drain()

        # 读取输出直到哨兵出现
        try:
            async with asyncio.timeout(self._timeout):
                while True:
                    await asyncio.sleep(self._output_delay)
                    output: str = self._process.stdout._buffer.decode()
                    if sentinel_before in output:
                        # 处理输出和错误码
                        output, pivot, exit_banner = output.rpartition(sentinel_before)
                        error_code_str, pivot, _ = exit_banner.partition(sentinel_after)
                        if not pivot or not error_code_str.isdecimal():
                            continue
                        error_code = int(error_code_str)
                        break
        except asyncio.TimeoutError:
            self._timed_out = True
            raise ToolError(
                f"timed out: bash has not returned in {self._timeout} seconds and must be restarted",
            ) from None

        # 清理输出
        if output.endswith("\n"):
            output = output[:-1]
            
        error: str = self._process.stderr._buffer.decode()
        if error.endswith("\n"):
            error = error[:-1]

        # 清空缓冲区
        self._process.stdout._buffer.clear()
        self._process.stderr._buffer.clear()

        return ToolExecResult(output=output, error=error, error_code=error_code)
```

### 3.3 顺序思考工具 (SequentialThinkingTool)

顺序思考工具帮助智能体进行深入的分析和思考。

#### 3.3.1 工具实现

```python
class SequentialThinkingTool(Tool):
    def get_name(self) -> str:
        return "sequentialthinking"

    def get_description(self) -> str:
        return """Break down complex problems into sequential thoughts.
Use this tool when you need to think through a problem step by step.
You can run bash commands or use other tools between thoughts.
"""

    def get_parameters(self) -> list[ToolParameter]:
        return [
            ToolParameter(
                name="total_thoughts",
                type="integer",
                description="Total number of thoughts to generate.",
                required=True,
            ),
            ToolParameter(
                name="current_thought_index",
                type="integer",
                description="Current thought index (1-based).",
                required=True,
            ),
            ToolParameter(
                name="thought",
                type="string",
                description="The current thought content.",
                required=True,
            ),
            ToolParameter(
                name="is_final",
                type="boolean",
                description="Whether this is the final thought.",
                required=False,
            ),
        ]

    async def execute(self, arguments: ToolCallArguments) -> ToolExecResult:
        total_thoughts = arguments.get("total_thoughts")
        current_thought_index = arguments.get("current_thought_index")
        thought = arguments.get("thought")
        is_final = arguments.get("is_final", False)
        
        if not all(isinstance(x, int) for x in [total_thoughts, current_thought_index]):
            return ToolExecResult(
                error="total_thoughts and current_thought_index must be integers",
                error_code=-1
            )
            
        if not isinstance(thought, str):
            return ToolExecResult(
                error="thought must be a string",
                error_code=-1
            )
        
        # 生成响应
        response = f"Thought {current_thought_index}/{total_thoughts}: {thought}"
        if is_final:
            response += "\n\nThis concludes my sequential thinking process."
            
        return ToolExecResult(output=response)
```

### 3.4 任务完成工具 (TaskDoneTool)

任务完成工具用于标记任务完成。

#### 3.4.1 工具实现

```python
class TaskDoneTool(Tool):
    def get_name(self) -> str:
        return "task_done"

    def get_description(self) -> str:
        return "Mark the task as completed."

    def get_parameters(self) -> list[ToolParameter]:
        return [
            ToolParameter(
                name="reason",
                type="string",
                description="Reason for marking the task as completed.",
                required=False,
            )
        ]

    async def execute(self, arguments: ToolCallArguments) -> ToolExecResult:
        reason = arguments.get("reason", "Task completed successfully.")
        return ToolExecResult(
            output=f"Task marked as completed. Reason: {reason}"
        )
```

## 4. 工具注册和管理

### 4.1 工具注册表

工具通过注册表进行管理：

```python
# tools/__init__.py
tools_registry: dict[str, type[Tool]] = {
    "bash": BashTool,
    "str_replace_based_edit_tool": TextEditorTool,
    "json_edit_tool": JSONEditTool,
    "sequentialthinking": SequentialThinkingTool,
    "task_done": TaskDoneTool,
    "ckg": CKGTool,
}
```

### 4.2 工具初始化

在智能体初始化时，工具会被创建：

```python
def __init__(
    self, agent_config: AgentConfig, docker_config: dict | None = None, docker_keep: bool = True
):
    # ... 其他初始化代码
    self._tools: list[Tool] = [
        tools_registry[tool_name](model_provider=self._model_config.model_provider.provider)
        for tool_name in agent_config.tools
    ]
```

## 5. 工具执行器

### 5.1 工具执行器实现

```python
class ToolExecutor:
    def __init__(self, tools: list[Tool]):
        self._tools = tools
        self._tool_map = {tool.name: tool for tool in tools}

    async def parallel_tool_call(self, tool_calls: list[ToolCall]) -> list[ToolResult]:
        """并行执行工具调用"""
        return await asyncio.gather(*[self.execute_tool_call(call) for call in tool_calls])

    async def sequential_tool_call(self, tool_calls: list[ToolCall]) -> list[ToolResult]:
        """顺序执行工具调用"""
        results = []
        for call in tool_calls:
            result = await self.execute_tool_call(call)
            results.append(result)
        return results

    async def execute_tool_call(self, tool_call: ToolCall) -> ToolResult:
        """执行单个工具调用"""
        tool_name = tool_call.name
        if tool_name not in self._tool_map:
            return ToolResult(
                call_id=tool_call.call_id,
                name=tool_name,
                success=False,
                error=f"Tool {tool_name} not found",
            )
        
        tool = self._tool_map[tool_name]
        try:
            result = await tool.execute(tool_call.arguments)
            result.call_id = tool_call.call_id
            result.name = tool_name
            return result
        except Exception as e:
            return ToolResult(
                call_id=tool_call.call_id,
                name=tool_name,
                success=False,
                error=str(e),
            )

    async def close_tools(self):
        """关闭所有工具资源"""
        for tool in self._tools:
            try:
                await tool.close()
            except Exception:
                pass
```

### 5.2 Docker工具执行器

在Docker模式下，使用专门的执行器：

```python
class DockerToolExecutor:
    async def execute_tool_call(self, tool_call: ToolCall) -> ToolResult:
        """在Docker环境中执行工具调用"""
        tool_name = tool_call.name
        
        # 如果是Docker工具，则在容器中执行
        if tool_name in self._docker_tools:
            return await self._execute_in_docker(tool_call)
        else:
            # 否则在主机上执行
            return await self._original_executor.execute_tool_call(tool_call)
```

## 6. 工具开发指南

### 6.1 创建新工具

要创建新工具，需要：

1. 继承 `Tool` 基类
2. 实现所有抽象方法
3. 在工具注册表中注册

```python
class CustomTool(Tool):
    def get_name(self) -> str:
        return "custom_tool"

    def get_description(self) -> str:
        return "A custom tool for demonstration purposes."

    def get_parameters(self) -> list[ToolParameter]:
        return [
            ToolParameter(
                name="param1",
                type="string",
                description="A sample parameter.",
                required=True,
            )
        ]

    async def execute(self, arguments: ToolCallArguments) -> ToolExecResult:
        param1 = arguments.get("param1")
        # 执行工具逻辑
        result = f"Custom tool executed with param1: {param1}"
        return ToolExecResult(output=result)
```

### 6.2 注册新工具

在 `tools/__init__.py` 中添加：

```python
tools_registry: dict[str, type[Tool]] = {
    # ... 现有工具
    "custom_tool": CustomTool,
}
```

### 6.3 工具测试

为工具编写测试用例：

```python
# tests/tools/test_custom_tool.py
import pytest
from trae_agent.tools.custom_tool import CustomTool

@pytest.mark.asyncio
async def test_custom_tool():
    tool = CustomTool()
    assert tool.get_name() == "custom_tool"
    
    result = await tool.execute({"param1": "test"})
    assert result.success
    assert "test" in result.output
```

## 7. 最佳实践

### 7.1 工具设计原则

1. **单一职责**: 每个工具应该有明确的单一功能
2. **参数验证**: 严格验证输入参数
3. **错误处理**: 提供清晰的错误信息
4. **资源管理**: 正确管理资源的获取和释放
5. **安全性**: 避免执行危险操作

### 7.2 工具使用建议

1. **路径规范**: 所有文件路径必须使用绝对路径
2. **输出控制**: 避免产生过大的输出
3. **命令执行**: 长时间运行的命令应在后台执行
4. **错误反馈**: 及时反馈执行结果和错误信息

## 8. 总结

Trae Agent 的工具系统是一个强大而灵活的组件，它通过以下特性实现了丰富的功能：

1. **插件化架构**: 支持动态注册和扩展工具
2. **标准化接口**: 所有工具遵循统一的接口规范
3. **异步执行**: 支持并行和顺序执行工具调用
4. **多环境支持**: 支持本地和Docker环境执行
5. **完善错误处理**: 提供详细的错误信息和处理机制

通过深入理解工具系统的设计和实现，开发者可以更好地使用现有工具或开发新的工具来扩展Trae Agent的功能。